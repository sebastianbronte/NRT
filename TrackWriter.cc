/**
 * TrackWriter class implementation
 * 
 * Author: Sebastian Bronte Palacios. sebastian.bronte@depeca.uah.es
 * 
 * This writes to disk the map, camera poses and other data generated by the
 * Mapping thread, which can be loaded from other applications to work on it.
 * 
 */

#include "TrackWriter.h"
//#include "VisualNRTracker.h"
//#include "NRTracker.h"
#include "Tracker.h"
#include "NRTrackerData.h"
#include <gvars3/instances.h>

/**
 * Class constructor
 * 
 * @param tracker that the data is to be taken
 */
TrackWriter::TrackWriter(AbstractTracker &track):mTracker(track)//,filename_points("outputdata_model.txt"),filename_poses("outputdata_poses.txt")
{
  std::string pattern = GVars3::GV3::get<std::string>("odata","");
  if(!pattern.empty())
  {
    filename_featurepoints = filename_poses = filename_quality = filename_raw = filename_coeffs = pattern;
    filename_featurepoints.append("_features.txt");
    filename_poses.append("_tracking_poses.txt");
    filename_quality.append("_quality.txt");
    filename_raw.append("_rawtracks.txt");
    filename_coeffs.append("_coefs.txt");

    outfile1.open(filename_featurepoints.c_str());
    outfile2.open(filename_poses.c_str());
    outfile3.open(filename_quality.c_str());
    outfile4.open(filename_raw.c_str());
    outfile5.open(filename_coeffs.c_str());
  }
  else
  {
    filename_featurepoints = filename_poses = std::string("");
  }
}

/**
 * Destructor to close all the files already opened
 */
TrackWriter::~TrackWriter()
{
  if(!filename_featurepoints.empty())
  {
    outfile1.close();
    outfile2.close();
    outfile3.close();
    outfile4.close();
    outfile5.close();
  }
}

/**
 * Collects the data from the current frame and sends it to the buffers that
 * are to be written to disk
 */
void TrackWriter::saveCurrentFrameData()
{
  if(!filename_featurepoints.empty())
  {
    //save map based tracking data
    buffer_poses.push_back(mTracker.GetCurrentPose());
    std::vector<NRTrackerData*> & vIterationSet = mTracker.getvIterationSet();
    unsigned int nmeas = vIterationSet.size();
    if(nmeas)
    {
      buffer_nfeaturesperframe.push_back(nmeas);
      for(unsigned int i=0;i<nmeas;i++)
      {
        NRTrackerData * TD = vIterationSet[i];
        buffer_featurepoints.push_back(TD->v2Found);
        buffer_pointindex.push_back(TD->Point.dCreationTime);
        buffer_pointcovariance.push_back(TD->v2Error_CovScaled);
        buffer_found.push_back(TD->bFound);
        buffer_level.push_back(TD->nSearchLevel);
        buffer_outliers.push_back(TD->bOutlier);
        buffer_3dpoints.push_back(TD->Point.v3WorldPos);
      }
      buffer_quality.push_back(mTracker.getTrackingQuality());
    }
    else
    {
      unsigned int nmeas = vIterationSet.size();
      buffer_nfeaturesperframe.push_back(nmeas);
      for(unsigned int i=0;i<nmeas;i++)
      {
        NRTrackerData * TD = vIterationSet[i];
        buffer_featurepoints.push_back(TD->v2Found);
        buffer_pointindex.push_back(TD->Point.dCreationTime);
        buffer_pointcovariance.push_back(TD->v2Error_CovScaled);
        buffer_found.push_back(TD->bFound);
        buffer_level.push_back(TD->nSearchLevel);
        buffer_outliers.push_back(TD->bOutlier);
        buffer_3dpoints.push_back(TD->Point.v3WorldPos);
      }
      buffer_quality.push_back(mTracker.getTrackingQuality());
    }

    KeyFrame & KF = mTracker.getCurrentKF();
    //saving raw tracking data
    for(unsigned int i=0;i<4;i++)
    {
      nmeas = KF.aLevels[i].vCorners.size();
      //buffer_nfeaturesperframe_raw.push_back(nmeas);
      outfile4 << nmeas << std::endl;
      for(unsigned int j=0;j<nmeas;j++)
      {
        //buffer_featurepoints_raw.push_back(KF.aLevels[i].vCorners[j]);
        outfile4 << KF.aLevels[i].vCorners[j].x << ' ' << KF.aLevels[i].vCorners[j].y << ' ' << i << std::endl;
      }
    }

    int nbases = mTracker.getNBasis();
    std::vector<double> vector_tmp;
    const double * coefs = mTracker.getCoefs();
    for(int i=0;i<nbases;i++)
    {
      vector_tmp.push_back(coefs[i]);
    }
    if(nbases)
      buffer_coeffs.push_back(vector_tmp);
      writeToDisk();
  }
}

/**
 * This function writes the buffers to the disk in the addecuate format
 */
void TrackWriter::writeToDisk(){ 
  unsigned int i,j;
  if(!filename_featurepoints.empty())
  {
    //first file: tracks and more stuff
    for( i=0;i<buffer_nfeaturesperframe.size();i++)
    {
      unsigned int nfeatures = buffer_nfeaturesperframe[i];
      outfile1 << nfeatures << std::endl;
      for(j=0;j<nfeatures;j++)
        outfile1 << buffer_featurepoints[i*nfeatures+j][0] << ' ' << buffer_featurepoints[i*nfeatures+j][1] << ' ' << buffer_pointindex[i*nfeatures+j] << ' ' << buffer_pointcovariance[i*nfeatures+j][0] << ' ' << buffer_pointcovariance[i*nfeatures+j][1] << ' ' << buffer_found[i*nfeatures+j] << ' ' << buffer_level[i*nfeatures+j] << ' ' << buffer_outliers[i*nfeatures+j] << ' ' << buffer_3dpoints[i*nfeatures+j][0] << ' ' << buffer_3dpoints[i*nfeatures+j][1] << ' ' << buffer_3dpoints[i*nfeatures+j][2] << std::endl;
    }
    buffer_nfeaturesperframe.clear();
    buffer_featurepoints.clear();
    buffer_pointindex.clear();
    buffer_found.clear();
    buffer_level.clear();
    buffer_pointcovariance.clear();
    buffer_outliers.clear();
    buffer_3dpoints.clear();

    SO3<double> tmp1;
    Matrix<3,3,double> tmp;
    Vector<3> tmp2;
    //second file: tracking poses detected
    for (i=0;i<buffer_poses.size();i++)
    {
      tmp1 = buffer_poses[i].get_rotation();
      tmp = tmp1.get_matrix();
      tmp2 = buffer_poses[i].get_translation();
      outfile2 << tmp[0][0] << '\t' << tmp[0][1] << '\t' << tmp[0][2] << '\t' << tmp[1][0] << '\t' << tmp[1][1] << '\t' << tmp[1][2] << '\t' << tmp[2][0] << '\t' << tmp[2][1] << '\t' << tmp[2][2] << '\t' << tmp2[0] << '\t' << tmp2[1] << '\t' << tmp2[2] << std::endl;
    }
    buffer_poses.clear();

    //third file: tracking quality for each frame
    for (i=0;i<buffer_quality.size();i++)
    {
      outfile3 << buffer_quality[i] << std::endl;
    }
    buffer_quality.clear();

    //fourth file: raw tracking data

    /*unsigned int level = 0;
    for( i=0;i<buffer_nfeaturesperframe_raw.size();i++) //for each frame
    {
      unsigned int nfeatures = buffer_nfeaturesperframe_raw[i];
      outfile4 << nfeatures << std::endl;
      for(j=0;j<nfeatures;j++)
        outfile4 << buffer_featurepoints_raw[i*nfeatures+j].x << ' ' << buffer_featurepoints_raw[i*nfeatures+j].y << ' ' << level << std::endl;
      if(level <3)
        level++;
      else
        level=0;
    }*/

    //fifth file: write coefficient information

    for(i=0;i<buffer_coeffs.size();i++)
    {
      std::vector<double> vector_tmp = buffer_coeffs[i];
      for(j=0;j<vector_tmp.size();j++)
      {
        double double_tmp = vector_tmp[j];
        outfile5 << double_tmp << '\t';
      }
      outfile5 << std::endl;
    }
    buffer_coeffs.clear();

  }
}
